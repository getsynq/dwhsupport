// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/getsynq/dwhsupport/exec/querier (interfaces: Querier)
//
// Generated by this command:
//
//	mockgen -typed -package=querier -destination=exec/querier/mocks.go github.com/getsynq/dwhsupport/exec/querier Querier
//

// Package scrapper is a generated GoMock package.
package querier

import (
	context "context"
	reflect "reflect"

	exec "github.com/getsynq/dwhsupport/exec"
	gomock "go.uber.org/mock/gomock"
)

// MockQuerier is a mock of Querier interface.
type MockQuerier[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockQuerierMockRecorder[T]
	isgomock struct{}
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder[T any] struct {
	mock *MockQuerier[T]
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier[T any](ctrl *gomock.Controller) *MockQuerier[T] {
	mock := &MockQuerier[T]{ctrl: ctrl}
	mock.recorder = &MockQuerierMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier[T]) EXPECT() *MockQuerierMockRecorder[T] {
	return m.recorder
}

// Close mocks base method.
func (m *MockQuerier[T]) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockQuerierMockRecorder[T]) Close() *MockQuerierCloseCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockQuerier[T])(nil).Close))
	return &MockQuerierCloseCall[T]{Call: call}
}

// MockQuerierCloseCall wrap *gomock.Call
type MockQuerierCloseCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierCloseCall[T]) Return(arg0 error) *MockQuerierCloseCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierCloseCall[T]) Do(f func() error) *MockQuerierCloseCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierCloseCall[T]) DoAndReturn(f func() error) *MockQuerierCloseCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockQuerier[T]) Exec(ctx context.Context, sql string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", ctx, sql)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockQuerierMockRecorder[T]) Exec(ctx, sql any) *MockQuerierExecCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockQuerier[T])(nil).Exec), ctx, sql)
	return &MockQuerierExecCall[T]{Call: call}
}

// MockQuerierExecCall wrap *gomock.Call
type MockQuerierExecCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierExecCall[T]) Return(arg0 error) *MockQuerierExecCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierExecCall[T]) Do(f func(context.Context, string) error) *MockQuerierExecCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierExecCall[T]) DoAndReturn(f func(context.Context, string) error) *MockQuerierExecCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryAndProcessMany mocks base method.
func (m *MockQuerier[T]) QueryAndProcessMany(ctx context.Context, sql string, handler func(context.Context, []*T) error, opts ...exec.QueryManyOpt[T]) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql, handler}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryAndProcessMany", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryAndProcessMany indicates an expected call of QueryAndProcessMany.
func (mr *MockQuerierMockRecorder[T]) QueryAndProcessMany(ctx, sql, handler any, opts ...any) *MockQuerierQueryAndProcessManyCall[T] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql, handler}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryAndProcessMany", reflect.TypeOf((*MockQuerier[T])(nil).QueryAndProcessMany), varargs...)
	return &MockQuerierQueryAndProcessManyCall[T]{Call: call}
}

// MockQuerierQueryAndProcessManyCall wrap *gomock.Call
type MockQuerierQueryAndProcessManyCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierQueryAndProcessManyCall[T]) Return(arg0 error) *MockQuerierQueryAndProcessManyCall[T] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierQueryAndProcessManyCall[T]) Do(f func(context.Context, string, func(context.Context, []*T) error, ...exec.QueryManyOpt[T]) error) *MockQuerierQueryAndProcessManyCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierQueryAndProcessManyCall[T]) DoAndReturn(f func(context.Context, string, func(context.Context, []*T) error, ...exec.QueryManyOpt[T]) error) *MockQuerierQueryAndProcessManyCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryMany mocks base method.
func (m *MockQuerier[T]) QueryMany(ctx context.Context, sql string, opts ...exec.QueryManyOpt[T]) ([]*T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryMany", varargs...)
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryMany indicates an expected call of QueryMany.
func (mr *MockQuerierMockRecorder[T]) QueryMany(ctx, sql any, opts ...any) *MockQuerierQueryManyCall[T] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryMany", reflect.TypeOf((*MockQuerier[T])(nil).QueryMany), varargs...)
	return &MockQuerierQueryManyCall[T]{Call: call}
}

// MockQuerierQueryManyCall wrap *gomock.Call
type MockQuerierQueryManyCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierQueryManyCall[T]) Return(arg0 []*T, arg1 error) *MockQuerierQueryManyCall[T] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierQueryManyCall[T]) Do(f func(context.Context, string, ...exec.QueryManyOpt[T]) ([]*T, error)) *MockQuerierQueryManyCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierQueryManyCall[T]) DoAndReturn(f func(context.Context, string, ...exec.QueryManyOpt[T]) ([]*T, error)) *MockQuerierQueryManyCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryMaps mocks base method.
func (m *MockQuerier[T]) QueryMaps(ctx context.Context, sql string) ([]exec.QueryMapResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryMaps", ctx, sql)
	ret0, _ := ret[0].([]exec.QueryMapResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryMaps indicates an expected call of QueryMaps.
func (mr *MockQuerierMockRecorder[T]) QueryMaps(ctx, sql any) *MockQuerierQueryMapsCall[T] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryMaps", reflect.TypeOf((*MockQuerier[T])(nil).QueryMaps), ctx, sql)
	return &MockQuerierQueryMapsCall[T]{Call: call}
}

// MockQuerierQueryMapsCall wrap *gomock.Call
type MockQuerierQueryMapsCall[T any] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierQueryMapsCall[T]) Return(arg0 []exec.QueryMapResult, arg1 error) *MockQuerierQueryMapsCall[T] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierQueryMapsCall[T]) Do(f func(context.Context, string) ([]exec.QueryMapResult, error)) *MockQuerierQueryMapsCall[T] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierQueryMapsCall[T]) DoAndReturn(f func(context.Context, string) ([]exec.QueryMapResult, error)) *MockQuerierQueryMapsCall[T] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
